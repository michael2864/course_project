Destructors&Destructors in C++@What is destructor?@Destructor is a member function which destructs or deletes an object.@@When is destructor called?@A destructor function is called automatically when the object goes out @of scope:@(1) the function ends@(2) the program ends@(3) a block containing local variables ends@(4) a delete operator is called &
Destructors&How destructors are different from a normal member function?@Destructors have same name as the class preceded by a tilde (~)@Destructors don’t take any argument and don’t return anything.@@Can there be more than one destructor in a class?@No, there can only one destructor in a class with classname preceded @by ~, no parameters and no return type.@@When do we need to write a user-defined destructor?@If we do not write our own destructor in class, compiler creates a default @destructor for us. The default destructor works fine unless we have @dynamically allocated memory or pointer in class. When a class contains a @pointer to memory allocated in class, we should write a destructor to @release memory before the class instance is destroyed. This must be @done to avoid memory leak.&
Destructors&Can a destructor be virtual?@Yes, In fact, it is always a good idea to make destructors virtual in base class@when we have a virtual function. See virtual destructor for more details.@@You may like to take a quiz on destructors.&
Destructors&Edited material&
Dynamic objects&If you write A * a = new A() the default constructor of the class A is called @and it dynamically allocates memory for one object of the class A and the @address of the memory allocated is assigned to the pointer a. So a points @an object of the class A and not an array. However, if you want an array of @A objects dynamically, then you'll have to write something like this @A * a = new A[10]. This will allocate memory of 10 objects of A. And you can@write a[0], a[1], ... a[9] to access the objects of the array.@Now, what would happen if we overload the [] operator? If we overload [] @operator, then it should mean that the class A has some sort of array inside, @and by writing a[1], where a is an object of class A, we want to get the@element situated at second index. (Speaking generally, you can mean @anything else using the subscript operator, but you should try to stick to @the original meaning of the subscript operator). But we cannot invoke [] @operator on pointers as it would mean to dereference the pointer. So to @invoke the subscript operator on a pointer of an object, we have to @explicitly call the subscript operator. Like this:@A * a = new A;@cout << a->operator[](0) << endl;&
Dynamic objects&It creates one object of the class A, and writing a->operator[](0). It explicitly @calls the overloaded subscript operator. What if we create an array @dynamically?@A * a = new A[6];@cout << a[0][0] << endl;@The first subscript operator is for getting the first object in the array of @objects. The second subscript operator is calling the overloaded subscript @operator of the object a[0]&
Theme&Empty&
aa&Empty&
aa&Empty&
